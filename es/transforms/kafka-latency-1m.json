{
    "source": {
        "index": "traces-*",
        "query": {
            "bool": {
                "filter": {
                    "bool" : {
                        "must" : [
                            {
                                "exists": {
                                    "field": "event.ingested"
                                }
                            },
                            {
                                "range": {
                                    "event.ingested": {
                                        "gte": "now-1h/m"
                                    }
                                }
                            },
                            {
                                "exists": {
                                    "field": "trace.id"
                                }
                            },
                            {
                                "exists": {
                                    "field": "span.id"
                                }
                            },
                            {
                                "exists": {
                                    "field": "service.name"
                                }
                            },
                            {
                                "exists": {
                                    "field": "timestamp.us"
                                }
                            }
                        ],
                        "should": [
                            { 
                                "bool": {
                                    "must": [
                                        {
                                            "term": {
                                                "span.type": "messaging"
                                            }
                                        },
                                        {
                                            "exists": {
                                                "field": "span.message.queue.name"
                                            }
                                        }
                                    ]
                                }
                            },
                            { 
                                "bool": {
                                    "must": [
                                        {
                                            "term": {
                                                "transaction.type": "messaging"
                                            }
                                        },
                                        {
                                            "exists": {
                                                "field": "transaction.message.queue.name"
                                            }
                                        }
                                    ]
                                }
                            }
                        ],
                        "minimum_should_match" : 1
                    }
                }
            }
        }
    },
    "dest": {
        "index": "kafka-latency-1m"
    },
    "sync": {
        "time": {
            "field": "event.ingested",
            "delay": "60s"
        }
    },
    "pivot": {
        "group_by": {
            "trace.id": {
                "terms": {
                    "field": "trace.id"
                }
            }
        },
        "aggregations": {
            "paths": {
                "scripted_metric": {
                    "init_script": "state.docs = []",
                    "map_script": "
                        Map span = [
                            '@timestamp':doc['@timestamp'].value,
                            'timestamp.us':doc['timestamp.us'].value,
                            'service.name':doc['service.name'].value,
                            'span.id':doc['span.id'].value
                        ];

                        if (doc.containsKey('parent.id') && (doc['parent.id'].size() > 0)) {
                            span['parent.id'] = doc['parent.id'].value;
                        }

                        /* copy message queue name */
                        if (doc.containsKey('span.message.queue.name') && (doc['span.message.queue.name'].size() > 0)) {
                            span['message.queue.name'] = doc['span.message.queue.name'].value;
                        }
                        else if (doc.containsKey('transaction.message.queue.name') && (doc['transaction.message.queue.name'].size() > 0)) {
                            span['message.queue.name'] = doc['transaction.message.queue.name'].value;
                        }

                        /* bookend queues with exit (enqueue) and enter (dequeue) labels */
                        if (doc.containsKey('span.action') && (doc['span.action'].size() > 0)) {
                            if (doc['span.action'].value.equals('publish')) {
                                span['kind'] = 'exit';
                            } else {
                                span['kind'] = 'enter';
                            }
                        } 
                        else if (doc.containsKey('labels.messaging_operation') && (doc['labels.messaging_operation'].size() > 0)) {
                            if (doc['labels.messaging_operation'].value.equals('process')) {
                                span['kind'] = 'enter';
                            } else {
                                span['kind'] = 'exit';
                            }
                        }

                        span['attributes'] = new HashMap();
                        if (params['_source'].keySet().contains('labels')) {
                            def labels = params['_source']['labels'].keySet();
                            for (label in labels) {
                                if (label.contains('com_example')) {
                                    span['attributes'][label] = params['_source']['labels'][label];
                                }
                            }
                        }
                        
                        /* copy all docs from this shard */
                        state.docs.add(span);
                    ",
                    "combine_script": "return state.docs;",
                    "reduce_script": "
                        /* build graph */
                        boolean attach_to_parent(def states, def child) {
                            def isolated = true;
                            /* for all shards */
                            for (s in states) {
                                /* for all docs in that shard */
                                for (span in s) {
                                    if (span.containsKey('children') == false) {
                                        span['children'] = [];
                                    }
                                    if (span['span.id'].equals(child['parent.id'])) {
                                        /* assign child to parent */
                                        span['children'].add(child);
                                        /* parent found, can't be root */
                                        isolated = false;
                                    }
                                }
                            }
                            return isolated;
                        } 

                        /* build paths */
                        void build_paths(def path, def node, def out_paths, def out_queues, def root_time, def enqueue_time, def enqueue_service) {
                            if (node.containsKey('children')) {
                                /* exiting queue, record hop-by-hop metrics */
                                if ((node['kind'].equals('enter')) && (enqueue_time > 0)) {
                                    def new_queue_doc = new HashMap();
                                    new_queue_doc['path'] = enqueue_service + '-' + node['service.name'];
                                    new_queue_doc['duration.us'] = node['timestamp.us'] - enqueue_time;
                                    out_queues.add(new_queue_doc);
                                }
                            
                                /* leaf node, record e2e metrics */
                                if (node['children'].size() == 0) {
                                    def new_path = path;
                                    if (!new_path.equals('')) {
                                        new_path += '-';
                                    }
                                    new_path += node['service.name'];

                                    def new_path_doc = new HashMap();
                                    new_path_doc['path'] = new_path;
                                    new_path_doc['duration.us'] = node['timestamp.us'] - root_time;
                                    out_paths.add(new_path_doc);
                                    return;
                                }

                                /* middle node, build path */
                                for (child in node['children']) {
                                    def new_path = path;
                                    /* entering queue */
                                    if (node['kind'].equals('exit')) {
                                        if (!new_path.equals('')) {
                                            new_path += '-';
                                        }
                                        new_path += node['service.name'] + '-' + node['message.queue.name'];

                                        /* entering queue, record time for hop-by-hop metrics */
                                        enqueue_time = node['timestamp.us'];
                                        enqueue_service = node['service.name'];
                                    }
                                    /* recurse down this path */
                                    build_paths(new_path, child, out_paths, out_queues, root_time, enqueue_time, enqueue_service);
                                }
                            }
                        }

                        /* build graph */
                        def root = null;
                        def isolated_spans = [];
                        /* for all shards */
                        for (s in states) {
                            /* for all docs in that shard */
                            for (span in s) {
                                if (span.containsKey('parent.id') == false) {
                                    root = span;
                                } else {
                                    def isolated = attach_to_parent(states, span);
                                    if (isolated) {
                                        isolated_spans.add(span);
                                    }
                                }
                            }
                        }
                        
                        if ((root == null) && (isolated_spans.size() > 0)) {
                            isolated_spans.sort((HashMap o1, HashMap o2)->o1['timestamp.us'].compareTo(o2['timestamp.us']));
                            root = isolated_spans[0];
                            isolated_spans.remove(0);
                        }

                        def out_doc = new HashMap();

                        /* if there are any remaining isolated spans, then this is an incomplete doc */
                        if (isolated_spans.size() > 0) {
                            out_doc['isolated_spans'] = isolated_spans.size();
                            return out_doc;
                        }
                        if (root == null)
                            return out_doc;

                        /* build paths */
                        def path = '';
                        def out_paths = [];
                        def out_queues = [];
                        def root_time = root['timestamp.us'];
                        build_paths(path, root, out_paths, out_queues, root_time, 0, '');

                        /* output doc */
                        out_doc['timestamp'] = root['@timestamp'];
                        
                        def rand = new Random();

                        if (out_paths.size() > 0) {
                            /* randomly feature 1 e2e metric */
                            def rand_selection = rand.nextInt(out_paths.size());
                            out_doc['e2e.path'] = out_paths[rand_selection].path;
                            out_doc['e2e.duration.us'] = out_paths[rand_selection]['duration.us'];

                            /* record all e2e samples */
                            for (doc in out_paths) {
                                out_doc['sample.e2e.' + doc.path] = doc['duration.us'];
                            }
                        }

                        if (out_queues.size() > 0) {
                            /* randomly feature 1 hop-by-hop metric */
                            def rand_selection = rand.nextInt(out_queues.size());
                            out_doc['hop.path'] = out_queues[rand_selection].path;
                            out_doc['hop.duration.us'] = out_queues[rand_selection]['duration.us'];

                            /* record all hop-by-hop samples */
                            for (doc in out_queues) {
                                out_doc['sample.hop.' + doc.path] = doc['duration.us'];
                            }
                        }

                        out_doc['root.name'] = root['service.name'];
                        def keys = root['attributes'].keySet();
                        for (key in keys) {
                            out_doc[key] = root['attributes'][key];
                        }

                        return out_doc;
                    "
                }
            }
        }
    }
}